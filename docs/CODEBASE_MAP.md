---
last_mapped: 2026-02-07T22:00:00Z
total_files: 95
total_tokens: 258218
---

# AuraIO Codebase Map

> Auto-generated by Cartographer. Last mapped: 2026-02-07

## System Overview

AuraIO (Adaptive Uring Runtime Architecture) is a self-tuning asynchronous I/O library for Linux built on io_uring. It uses AIMD (Additive Increase Multiplicative Decrease) congestion control to automatically optimize I/O parameters for throughput and latency. The library provides C11, C++20, and Rust APIs.

```mermaid
graph TB
    subgraph "Public APIs"
        CAPI[auraio.h<br/>C API]
        CPPAPI[auraio.hpp<br/>C++ API]
        RustAPI[auraio crate<br/>Rust API]
    end

    subgraph "C++ Bindings"
        Engine[engine.hpp<br/>Engine class]
        Coro[coro.hpp<br/>Coroutines]
        CppBuf[buffer.hpp<br/>RAII buffers]
    end

    subgraph "Rust Bindings"
        RustSafe[auraio crate<br/>Safe wrapper]
        RustAsync[async_io.rs<br/>Futures]
        RustSys[auraio-sys<br/>FFI bindings]
    end

    subgraph "Exporters"
        Prom[prometheus<br/>Metrics formatter]
    end

    subgraph "Core C Library"
        Impl[auraio.c<br/>Implementation]
        Ring[adaptive_ring.c<br/>io_uring wrapper]
        Adaptive[adaptive_engine.c<br/>AIMD controller]
        BufPool[adaptive_buffer.c<br/>Buffer pool]
    end

    subgraph "External"
        liburing[liburing]
        Kernel[Linux Kernel<br/>io_uring]
    end

    CPPAPI --> Engine
    Engine --> Coro
    Engine --> CppBuf
    Engine --> CAPI
    RustAPI --> RustSafe
    RustSafe --> RustAsync
    RustSafe --> RustSys
    RustSys --> CAPI
    Prom --> CAPI
    CAPI --> Impl
    Impl --> Ring
    Impl --> Adaptive
    Impl --> BufPool
    Ring --> Adaptive
    Ring --> liburing
    liburing --> Kernel
```

## Directory Structure

```
AuraIO/
├── include/
│   ├── auraio.h              # Public C API (opaque types, all user-facing functions)
│   ├── auraio.hpp            # C++ umbrella header
│   └── auraio/
│       ├── engine.hpp        # Engine class with callbacks
│       ├── coro.hpp          # C++20 coroutine support (Task<T>, awaitables)
│       ├── buffer.hpp        # RAII buffer wrappers
│       ├── options.hpp       # Configuration wrapper
│       ├── request.hpp       # Request wrapper
│       ├── stats.hpp         # Stats wrapper
│       ├── error.hpp         # Exception types
│       ├── fwd.hpp           # Forward declarations
│       └── detail/
│           └── callback_storage.hpp  # Type-erased callback pool
├── src/
│   ├── auraio.c              # Public API implementation, ring selection, event loop
│   ├── adaptive_ring.c       # io_uring wrapper, request pool, completion handling
│   ├── adaptive_ring.h       # Ring internal interface
│   ├── adaptive_engine.c     # AIMD algorithm, P99 tracking, phase state machine
│   ├── adaptive_engine.h     # Adaptive controller interface, tuning constants
│   ├── adaptive_buffer.c     # Thread-safe aligned buffer pool with sharding
│   ├── adaptive_buffer.h     # Buffer pool interface
│   └── internal.h            # Shared utilities (timing, iovec helpers)
├── bindings/
│   └── rust/
│       ├── Cargo.toml        # Workspace: auraio-sys + auraio
│       ├── auraio-sys/       # Raw FFI bindings (bindgen-generated)
│       │   ├── build.rs      # Library detection + bindgen codegen
│       │   └── src/lib.rs    # Re-exports generated bindings
│       └── auraio/           # Safe Rust wrapper
│           └── src/
│               ├── lib.rs        # Public API re-exports, integration tests
│               ├── engine.rs     # Engine RAII wrapper, I/O methods
│               ├── buffer.rs     # Buffer (RAII) + BufferRef (Copy)
│               ├── callback.rs   # Type-erased FFI trampoline
│               ├── async_io.rs   # AsyncEngine trait, IoFuture
│               ├── options.rs    # Builder-pattern config
│               ├── request.rs    # RequestHandle (pending op)
│               ├── error.rs      # Error enum (thiserror)
│               └── stats.rs      # Stats snapshot
├── exporters/
│   └── prometheus/
│       ├── auraio_prometheus.h   # Prometheus formatter API
│       ├── auraio_prometheus.c   # Text exposition format implementation
│       └── example.c             # Minimal HTTP server on :9091/metrics
├── examples/
│   ├── C/
│   │   ├── quickstart.c      # Minimal read example
│   │   ├── simple_read.c     # Single file read with stats
│   │   ├── bulk_reader.c     # High-throughput directory scanner
│   │   ├── write_modes.c     # O_DIRECT vs buffered comparison
│   │   └── cancel_request.c  # In-flight request cancellation demo
│   ├── cpp/
│   │   ├── quickstart.cpp    # Minimal C++ async read
│   │   ├── simple_read.cpp   # C++ version of simple read
│   │   ├── bulk_reader.cpp   # C++ high-throughput scanner
│   │   ├── write_modes.cpp   # C++ write modes demo
│   │   └── coroutine_copy.cpp # C++20 coroutine file copy
│   ├── rust/
│   │   └── examples/
│   │       ├── quickstart.rs     # Minimal Rust async read
│   │       ├── simple_read.rs    # Read with stats reporting
│   │       ├── bulk_reader.rs    # Concurrent directory scanner
│   │       ├── file_copy.rs      # Synchronous-style file copy
│   │       ├── async_copy.rs     # Future-based async file copy
│   │       └── write_modes.rs    # O_DIRECT vs buffered comparison
│   └── Makefile
├── tools/
│   └── BFFIO/                   # FIO-compatible I/O benchmark (powered by AuraIO)
│       ├── main.c               # CLI entry point, engine lifecycle
│       ├── job_parser.h/.c      # .fio INI parser + CLI arg parser
│       ├── workload.h/.c        # I/O loop, worker threads, file management
│       ├── stats.h/.c           # Latency histograms, percentiles, aggregation
│       ├── output.h/.c          # FIO-compatible text + JSON formatters
│       ├── test_BFFIO.sh        # Functional test suite (14 tests)
│       ├── run_baseline.sh      # FIO vs BFFIO comparison with delta report
│       └── Makefile
├── tests/
│   ├── test_engine.c         # AIMD algorithm tests
│   ├── test_ring.c           # Ring management tests
│   ├── test_buffer.c         # Buffer pool tests
│   ├── test_stats.c          # Observability API tests
│   ├── test_ring_select.c    # Ring selection mode tests (ADAPTIVE/CPU_LOCAL/ROUND_ROBIN)
│   ├── test_cpp.cpp          # C++ binding tests
│   ├── stress_test.cpp       # Multi-threaded stress test
│   ├── perf_bench.c          # Performance benchmarks (throughput, latency, scalability)
│   ├── bench_buffer.c        # Buffer pool microbenchmark
│   ├── repro_race.c          # Race condition reproduction
│   ├── run_analysis.sh       # FIO comparison benchmark suite
│   ├── run_deep_analysis.sh  # Flamegraph/cachegrind/pahole profiling
│   ├── run_perf_test.sh      # Portable benchmark runner
│   └── Makefile
├── docs/
│   ├── api_reference.md      # Complete C and C++ API reference
│   ├── architecture.md       # Design philosophy, concurrency model, migration guide
│   ├── BFFIO.md              # BFFIO benchmark tool usage and architecture
│   ├── observability.md      # Metrics API, Prometheus, sampling cost analysis
│   └── performance.md        # Hardware-aware I/O design, internal optimizations
├── pkg/
│   └── libauraio.pc.in       # pkg-config template
├── Makefile                   # Main build system
└── README.md                  # User documentation
```

## Module Guide

### Public C API (`include/auraio.h` + `src/auraio.c`)

**Purpose**: User-facing C interface tying together rings, buffers, and adaptive control

**Entry point**: `include/auraio.h`

| File | Purpose | Tokens |
|------|---------|--------|
| `include/auraio.h` | Public types and function declarations | 8,049 |
| `src/auraio.c` | API implementation, ring selection modes, merged flush+poll | 12,608 |

**Key Types**:
- `auraio_engine_t` - Opaque engine handle
- `auraio_request_t` - Opaque request handle
- `auraio_buf_t` - Unified buffer descriptor (regular or registered)
- `auraio_callback_t` - Completion callback: `void (*)(auraio_request_t*, ssize_t, void*)`
- `auraio_stats_t` - Statistics snapshot (includes `adaptive_spills` counter)
- `auraio_ring_stats_t` - Per-ring metrics (ops, bytes, in_flight_limit, p99, aimd_phase)
- `auraio_histogram_t` - Latency histogram (200 buckets x 50us, 0-10ms range)
- `auraio_buffer_stats_t` - Buffer pool stats (allocated bytes, buffers, shards)
- `auraio_options_t` - Engine configuration (includes `ring_select` mode)
- `auraio_ring_select_t` - Ring selection mode enum: `ADAPTIVE`, `CPU_LOCAL`, `ROUND_ROBIN`

**Key Functions**:
- Lifecycle: `auraio_create()`, `auraio_create_with_options()`, `auraio_destroy()`
- I/O: `auraio_read()`, `auraio_write()`, `auraio_readv()`, `auraio_writev()`, `auraio_fsync()`
- Event loop: `auraio_poll()`, `auraio_wait()`, `auraio_run()`, `auraio_stop()`
- Buffers: `auraio_buffer_alloc()`, `auraio_buffer_free()`
- Registered I/O: `auraio_register_buffers()`, `auraio_register_files()`, `auraio_update_file()`
- Observability: `auraio_get_stats()`, `auraio_get_ring_stats()`, `auraio_get_histogram()`, `auraio_get_buffer_stats()`, `auraio_get_ring_count()`
- Cancellation: `auraio_cancel()`
- Version: `auraio_version()`, `auraio_version_int()`, `auraio_phase_name()`

**Ring Selection Modes**:
- **ADAPTIVE** (default): CPU-local with power-of-two spilling. Gate 1: spill if local ring pending >= 75% of in-flight limit. Gate 2: stay local if pending > 2x global average (outlier). Spill target: pick 2 random non-local rings, use lighter one.
- **CPU_LOCAL**: Strict CPU-affinity via TLS-cached `sched_getcpu()`. Best NUMA locality, no cross-ring traffic.
- **ROUND_ROBIN**: Atomic fetch-add counter for even distribution across all rings. Maximum single-thread scaling.

**Optimizations**:
- TLS-cached `sched_getcpu()` in `select_ring()` (refreshed every 32 submissions)
- Thread-local xorshift32 PRNG for power-of-two ring selection
- Merged flush+poll in `auraio_wait()` with early exit on first completion
- Eventfd draining to prevent spurious epoll wakeups
- Drift-free tick thread using `clock_nanosleep()` with `TIMER_ABSTIME`

**Dependencies**: All internal modules, liburing, pthread, eventfd

**Thread Safety**: Multiple threads can submit concurrently (per-ring locks); single thread should poll

---

### C++ Bindings (`include/auraio.hpp` + `include/auraio/*.hpp`)

**Purpose**: Modern C++20 interface with RAII, exceptions, concepts, and coroutines

**Entry point**: `include/auraio.hpp`

| File | Purpose | Tokens |
|------|---------|--------|
| `include/auraio.hpp` | Umbrella header | 427 |
| `include/auraio/engine.hpp` | Engine class, callbacks, concepts, per-ring stats | 4,238 |
| `include/auraio/coro.hpp` | Task<T>, IoAwaitable, FsyncAwaitable | 2,900 |
| `include/auraio/buffer.hpp` | Buffer (RAII), BufferRef (explicit const ctor) | 2,281 |
| `include/auraio/options.hpp` | Options wrapper with RingSelect | 1,242 |
| `include/auraio/request.hpp` | Request wrapper | 442 |
| `include/auraio/stats.hpp` | Stats, RingStats, Histogram, BufferStats | 1,316 |
| `include/auraio/error.hpp` | auraio::Error exception | 571 |
| `include/auraio/fwd.hpp` | Forward declarations | 94 |
| `include/auraio/detail/callback_storage.hpp` | 8-shard CallbackPool, type erasure | 2,055 |

**Key Classes**:
- `auraio::Engine` - Move-only engine wrapper with template callbacks, per-ring stats
- `auraio::Buffer` - RAII buffer owner (returns to pool on destruction)
- `auraio::BufferRef` - Lightweight buffer descriptor (explicit const ctor for safety)
- `auraio::Options` - Builder with `ring_select(RingSelect)` setter
- `auraio::RingSelect` - Enum: `Adaptive`, `CpuLocal`, `RoundRobin`
- `auraio::Stats` - Stats snapshot with `adaptive_spills()` getter
- `auraio::RingStats` - Per-ring metrics with `aimd_phase_name()` helper
- `auraio::Histogram` - Latency histogram with bucket accessors
- `auraio::BufferStats` - Buffer pool stats
- `auraio::Request` - Request wrapper
- `auraio::Error` - Exception with errno

**Coroutine Support** (C++20):
- `Task<T>` - Lazy coroutine returning T; destructor asserts if still pending
- `IoAwaitable` - Awaitable for read/write (yields `ssize_t`)
- `FsyncAwaitable` - Awaitable for fsync (yields `void`)
- Result consumption is destructive (`get()` moves out, subsequent calls throw)

**Patterns**:
- Type-erased callbacks via `std::function` + trampoline
- 8-shard `CallbackPool` for reduced mutex contention on many-core systems
- Move-only semantics prevent accidental copies
- Thread-local shard assignment via thread ID hash

---

### Rust Bindings (`bindings/rust/`)

**Purpose**: Safe, idiomatic Rust wrapper with RAII, async/await, and zero-cost abstractions

**Entry point**: `bindings/rust/auraio/src/lib.rs`

| File | Purpose | Tokens |
|------|---------|--------|
| `auraio-sys/build.rs` | Library detection + bindgen codegen | 781 |
| `auraio-sys/src/lib.rs` | Raw FFI re-exports | 450 |
| `auraio/src/lib.rs` | Public API, integration tests | 8,452 |
| `auraio/src/engine.rs` | Engine RAII wrapper, all I/O methods | 4,071 |
| `auraio/src/async_io.rs` | AsyncEngine trait, IoFuture | 3,919 |
| `auraio/src/buffer.rs` | Buffer (RAII, Drop) + BufferRef (Copy) | 1,810 |
| `auraio/src/callback.rs` | BoxedCallback, FFI trampoline, panic catch | 508 |
| `auraio/src/options.rs` | Builder-pattern config with RingSelect | 860 |
| `auraio/src/request.rs` | RequestHandle (pending op) | 930 |
| `auraio/src/error.rs` | Error enum via thiserror | 278 |
| `auraio/src/stats.rs` | Stats snapshot | 353 |

**Architecture**:
```
Application
    ↓
auraio crate (safe API: Engine, Buffer, AsyncEngine)
    ↓
auraio-sys crate (raw FFI, bindgen-generated)
    ↓
libauraio.so (C library)
```

**Key Types**:
- `Engine` - RAII wrapper (`Send + Sync`), destroyed on `Drop`
- `Buffer` - RAII pool buffer (`Send`, not `Sync`), freed on `Drop`
- `BufferRef` - Lightweight descriptor (`Copy`), no ownership
- `AsyncEngine` - Extension trait adding `async_read()`, `async_write()`, `async_fsync()`
- `IoFuture` - Runtime-agnostic future for async I/O
- `Options` - Builder with chainable setters including `ring_select(RingSelect)`
- `RingSelect` - Enum: `Adaptive`, `CpuLocal`, `RoundRobin`
- `Error` - `Io`, `EngineCreate`, `BufferAlloc`, `Submission`, `Cancelled`, `InvalidArgument`

**Callback Flow**:
1. Rust closure boxed as `BoxedCallback` (`Box<dyn FnOnce(Result<usize>) + Send>`)
2. `Box::into_raw()` transfers ownership to C library via `user_data` pointer
3. C library invokes `callback_trampoline()` on completion
4. Trampoline calls `Box::from_raw()`, invokes closure, drops context
5. Panics caught at FFI boundary via `catch_unwind` (prevents cross-FFI unwinding)

**Async Pattern**:
- `AsyncEngine` methods return `IoFuture` (shared `Arc<Mutex<IoState>>`)
- Callback stores result + invokes `Waker`
- Requires background thread calling `engine.wait()` to make progress
- Runtime-agnostic: no tokio/async-std dependency

**Gotchas**:
- `RequestHandle` becomes **invalid** after callback starts (dangling pointer)
- Inline C functions (`auraio_buf`, `auraio_buf_fixed`) reimplemented in Rust (bindgen can't handle inline)
- Async futures don't progress without `engine.wait()` calls
- `wrapping_neg()` used for errno conversion to avoid overflow panic on `isize::MIN`

---

### Prometheus Exporter (`exporters/prometheus/`)

**Purpose**: Standalone Prometheus text exposition format formatter for AuraIO metrics

| File | Purpose | Tokens |
|------|---------|--------|
| `auraio_prometheus.h` | Formatter API | 351 |
| `auraio_prometheus.c` | Text format implementation | 2,366 |
| `example.c` | HTTP server on :9091 | 1,253 |

**API**: `auraio_metrics_prometheus(engine, buf, buf_size)` - returns bytes written, negative if buffer too small

**Metrics exported** (30+):
- Aggregate: ops_completed, bytes_transferred, throughput, p99_latency, in_flight, ring_count
- Per-ring: ops, bytes, in_flight, in_flight_limit, batch_threshold, queue_depth, p99, throughput, aimd_phase
- Per-ring histograms: latency distribution with cumulative buckets
- Buffer pool: allocated_bytes, buffers, shards

**Patterns**:
- `PROM_APPEND` macro for safe buffer building with overflow detection
- NaN/Inf clamped to 0.0 (Prometheus format compliance)
- Cumulative histogram buckets (per Prometheus spec)
- No external dependencies beyond libc

**Gotchas**:
- Histogram sum is estimated using bucket midpoints (not exact)
- On overflow, returns `-written * 2 + 4096` as conservative retry estimate
- Example server is demo-quality (not production-grade)

---

### BFFIO Benchmark Tool (`tools/BFFIO/`)

**Purpose**: FIO-compatible I/O benchmark that uses AuraIO as its sole engine, demonstrating AIMD adaptive tuning advantages over fixed-depth io_uring

**Entry point**: `tools/BFFIO/main.c`

| File | Purpose | Tokens |
|------|---------|--------|
| `main.c` | CLI entry point, engine lifecycle, job dispatch | 2,290 |
| `job_parser.h` | Config structs (`job_config_t`, `bench_config_t`, `rw_pattern_t`) | 741 |
| `job_parser.c` | .fio INI parser + CLI `--flag=value` parser with `[global]` inheritance | 4,139 |
| `workload.h` | Worker types (`io_ctx_t`, `io_ctx_pool_t`, `thread_ctx_t`, `file_set_t`) | 768 |
| `workload.c` | I/O submit loop, worker threads, file setup, convergence detection | 6,198 |
| `stats.h` | Per-thread atomic stats, histogram (200 buckets x 50us), sample arrays | 1,066 |
| `stats.c` | Atomic recording, CAS min/max, histogram percentiles, aggregation | 4,521 |
| `output.h` | Formatter API (`output_normal`, `output_json`) | 253 |
| `output.c` | FIO-compatible text + FIO 3.36 JSON with `"AuraIO"` section | 6,516 |
| `test_BFFIO.sh` | Functional test suite (20+ tests) | 2,309 |
| `run_baseline.sh` | FIO vs BFFIO comparison with delta report + regression detection | 5,180 |
| `Makefile` | Build system with libauraio.a dependency | 285 |

**Key Design Patterns**:
- One fresh AuraIO engine per job — clean AIMD convergence per workload
- Pre-allocated `io_ctx_pool_t` per thread — zero malloc on I/O hot path (spinlock-protected for cross-thread callbacks)
- Per-thread `thread_stats_t` with relaxed atomics — no shared lock for stats
- CAS loops for min/max latency tracking
- xorshift64 PRNG for random offsets and rwmix decisions
- Two-phase measurement: ramp (discarded) + steady-state (reported)

**AIMD Auto-Tuning (`--target-p99`)**:
- User specifies P99 latency ceiling (e.g., `--target-p99=2ms`)
- Engine starts at `initial_in_flight=4`, AIMD probes upward
- Auto-scales `numjobs` to match ring count (one thread per ring for convergence)
- Stats reset when all rings reach STEADY/CONVERGED phase
- Output shows `max concurrency=N at p99=X.XXms (target: Y.YYms)`

**FIO Compatibility**:
- Accepts `.fio` job files with `[global]` and `[job]` sections
- Supports all common CLI flags (`--rw`, `--bs`, `--size`, `--direct`, etc.)
- JSON output matches FIO 3.36 structure (`jobs[].read/write` with percentiles)
- Adds `"AuraIO"` section in JSON with `final_depth`, `phase`, `p99_ms`
- Text output matches FIO format (IOPS/BW line, latency summary, percentile table)

**Thread Model**:
- N worker threads (pthread): submit loop + `auraio_wait(1ms)` + repeat
- Main thread: 1Hz timer for ramp detection, convergence polling, BW/IOPS sampling, runtime expiry
- Callbacks fire on any thread (hence spinlock-protected context pool)

**Gotchas**:
- File creation writes real 0xA5 pattern (defeats ext4 unwritten-extent optimization)
- O_DIRECT attempted first with buffered I/O fallback
- Histogram overflow bucket for latencies > 10ms
- `queue_depth` set to `iodepth * 2` (min 256) so AIMD has headroom below submission cap

See [docs/BFFIO.md](BFFIO.md) for full usage documentation.

---

### Ring Manager (`src/adaptive_ring.c/.h`)

**Purpose**: io_uring wrapper with request tracking, batching, and per-ring adaptive control

**Entry point**: `src/adaptive_ring.h`

| File | Purpose | Tokens |
|------|---------|--------|
| `src/adaptive_ring.h` | Ring interface, request struct, latency sampling config | 2,196 |
| `src/adaptive_ring.c` | Ring implementation, COOP_TASKRUN, batched CQE extraction | 6,512 |

**Key Types**:
- `ring_ctx_t` - Per-ring context (io_uring, request pool, mutex, adaptive controller)
- `auraio_request_t` - Request with callback, timing, cancellation state

**Key Functions**:
- `ring_init()`, `ring_destroy()` - Lifecycle
- `ring_submit_read()`, `ring_submit_write()`, `ring_submit_fsync()` - Submission
- `ring_submit_read_fixed()`, `ring_submit_write_fixed()` - Registered buffer I/O
- `ring_poll()`, `ring_wait()` - Completion processing
- `ring_get_request()`, `ring_put_request()` - O(1) request pool

**Patterns**:
- Free stack for O(1) request allocation
- Lock released during callback to allow re-entrant submission
- SQPOLL with graceful fallback to normal mode
- `process_completion()` manages its own locking internally
- `IORING_SETUP_COOP_TASKRUN` for cooperative completions (kernel 5.19+)
- Selective request zeroing (only fields that vary between op types)
- Batched CQE extraction (up to 32 per lock hold, `RING_POLL_BATCH`)
- 1-in-8 latency sampling (`RING_LATENCY_SAMPLE_RATE`)

**Gotchas**:
- Request handle only valid until callback begins
- Callers must NOT hold lock when calling `process_completion()`
- Callbacks can submit new I/O (re-entry safe)

---

### Adaptive Engine (`src/adaptive_engine.c/.h`)

**Purpose**: AIMD congestion control for automatic I/O tuning

**Entry point**: `src/adaptive_engine.h`

| File | Purpose | Tokens |
|------|---------|--------|
| `src/adaptive_engine.h` | Controller interface, constants, cache-line layout | 3,204 |
| `src/adaptive_engine.c` | AIMD implementation, low-IOPS handling | 3,886 |

**Key Types**:
- `adaptive_controller_t` - Per-ring controller state
- `adaptive_phase_t` - State machine phases
- `adaptive_histogram_t` - P99 latency tracking (50us buckets, 200 buckets)

**Key Functions**:
- `adaptive_init()`, `adaptive_destroy()` - Lifecycle
- `adaptive_tick()` - Called every 10ms, runs AIMD algorithm
- `adaptive_record_completion()` - Record latency sample (lock-free atomic)
- `adaptive_get_inflight_limit()`, `adaptive_get_batch_threshold()` - Current tuned values

**AIMD State Machine**:
```
BASELINE (warmup, 100ms)
    ↓
PROBING (additive increase: +1/tick)
    ↓ plateau OR latency spike
BACKOFF (multiplicative decrease: x0.8)
    ↓
SETTLING (wait 100ms)
    ↓
STEADY (maintain config)
    ↓ stable for 5s
CONVERGED (no more changes)
```

**Key Constants** (tuned for NVMe SSDs):
```c
ADAPTIVE_SAMPLE_INTERVAL_MS    = 10     // Tick every 10ms
ADAPTIVE_WARMUP_SAMPLES        = 10     // 100ms baseline
ADAPTIVE_AIMD_INCREASE         = 1      // Add 1 per tick
ADAPTIVE_AIMD_DECREASE         = 0.80   // Cut 20% on backoff
ADAPTIVE_LATENCY_GUARD_MULT    = 10.0   // Backoff if P99 > 10x baseline
ADAPTIVE_DEFAULT_LATENCY_GUARD = 10.0   // Hard ceiling: 10ms P99
```

**Cache-Line Layout**: `adaptive_controller_t` hot fields (limits, counters) packed into cache line 0; tick-only state (phase, sliding windows) in subsequent lines

**Gotchas**:
- Histogram swap uses `adaptive_hist_reset()` with atomic stores (not memset)
- P99 requires minimum 20 samples for validity
- Low-IOPS handling: extended sample window when insufficient data

---

### Buffer Pool (`src/adaptive_buffer.c/.h`)

**Purpose**: Thread-safe 4KB-aligned buffer pool with size-class buckets

**Entry point**: `src/adaptive_buffer.h`

| File | Purpose | Tokens |
|------|---------|--------|
| `src/adaptive_buffer.h` | Pool interface | 1,355 |
| `src/adaptive_buffer.c` | Pool implementation, TLS caching, CAS registration | 4,876 |

**Three-Tier Architecture**:
```
Thread Cache (TLS, no lock, ~10ns)
    ↓ cache miss
Shard (per-shard lock, ~50ns)
    ↓ shard empty
posix_memalign (slow path)
```

**Size Classes**: 16 classes from 4KB to 128MB (power-of-2)

**Auto-Scaling Shards**: 2-256 shards (~4 threads/shard target, power-of-2 rounding)

**Patterns**:
- `__builtin_clzl()` for O(1) size-to-class mapping
- Batch transfers (4 at a time) between cache and shard
- High-water mark limits cached buffers (default 256/shard)
- Lock-free TLS cache registration via CAS
- Pool liveness check via atomic `destroyed` flag

---

### Internal Utilities (`src/internal.h`)

**Purpose**: Shared utilities across modules

| File | Purpose | Tokens |
|------|---------|--------|
| `src/internal.h` | Timing, iovec helpers, TSan annotations | 525 |

**Exports**:
- `get_time_ns()` - Monotonic nanosecond clock (CLOCK_MONOTONIC)
- `iovec_total_len()` - Safe vectored I/O size with overflow check
- `TSAN_RELEASE()`/`TSAN_ACQUIRE()` - ThreadSanitizer annotations for io_uring's kernel-mediated synchronization

---

## Data Flow

### Read Operation

```mermaid
sequenceDiagram
    participant User
    participant API as auraio.c
    participant Ring as adaptive_ring.c
    participant Kernel as io_uring

    User->>API: auraio_read(engine, fd, buf, len, offset, cb, ud)
    API->>API: select ring (CPU-aware via sched_getcpu)
    API->>Ring: ring_submit_read()
    Ring->>Ring: get request slot (O(1) free stack)
    Ring->>Kernel: io_uring_prep_read()
    Ring->>Ring: increment queued_sqes
    API->>Ring: ring_flush() if batch threshold
    Ring->>Kernel: io_uring_submit()

    Note over Kernel: I/O completes

    User->>API: auraio_wait()
    API->>Ring: ring_wait()
    Ring->>Kernel: io_uring_wait_cqe()
    Kernel-->>Ring: CQE with result
    Ring->>Ring: record latency (atomic)
    Ring->>Ring: release lock
    Ring->>User: callback(result, user_data)
    Ring->>Ring: re-acquire lock
    Ring->>Ring: return request slot
```

### Rust Callback Flow

```mermaid
sequenceDiagram
    participant App as Rust App
    participant Eng as Engine (Rust)
    participant CB as callback.rs
    participant C as C Library

    App->>Eng: engine.read(fd, buf, len, offset, closure)
    Eng->>CB: BoxedCallback::new(closure)
    CB->>CB: Box::into_raw() → *void
    Eng->>C: auraio_read(engine, ..., trampoline, user_data)

    Note over C: I/O completes

    C->>CB: callback_trampoline(req, result, user_data)
    CB->>CB: Box::from_raw(user_data)
    CB->>App: closure(Result<usize>)
    CB->>CB: Drop context
```

### Adaptive Tuning Flow

```mermaid
sequenceDiagram
    participant Tick as Tick Thread
    participant Ctrl as adaptive_controller_t
    participant Hist as Histogram

    loop Every 10ms
        Tick->>Ctrl: adaptive_tick()
        Ctrl->>Hist: swap active histogram (atomic index flip)
        Hist-->>Ctrl: old histogram
        Ctrl->>Ctrl: calculate P99 from old
        Ctrl->>Ctrl: calculate throughput
        Ctrl->>Ctrl: update sliding windows

        alt efficiency_ratio > epsilon
            Ctrl->>Ctrl: PROBING: in_flight += 1
        else latency > 10x baseline
            Ctrl->>Ctrl: BACKOFF: in_flight *= 0.8
        else plateau detected
            Ctrl->>Ctrl: STEADY: maintain config
        end

        Ctrl->>Hist: adaptive_hist_reset() (atomic stores)
    end
```

### Ring Selection (ADAPTIVE mode)

```mermaid
flowchart TD
    Submit["auraio_read/write()"]
    CPU["TLS-cached sched_getcpu()"]
    Local["Local ring = cpu % ring_count"]
    Gate1{"pending < 75%\nof in_flight_limit?"}
    Gate2{"pending > 2x\navg_ring_pending?"}
    Stay["Submit to local ring"]
    Spill["Power-of-two selection:\npick 2 random rings,\nuse lighter one"]
    Incr["Increment adaptive_spills"]

    Submit --> CPU --> Local --> Gate1
    Gate1 -->|Yes| Stay
    Gate1 -->|No| Gate2
    Gate2 -->|Yes: outlier| Stay
    Gate2 -->|No| Spill --> Incr
```

## Optimization Techniques

| Technique | Location | Impact |
|-----------|----------|--------|
| TLS-cached CPU routing | `auraio.c:select_ring()` | Refresh `sched_getcpu()` every 32 ops, not every op |
| Merged flush+poll | `auraio.c:auraio_wait()` | Single-pass with early exit on first completion |
| COOP_TASKRUN | `adaptive_ring.c:ring_init()` | Cooperative completions, fewer context switches (kernel 5.19+) |
| Batched CQE extraction | `adaptive_ring.c:ring_poll()` | Up to 32 CQEs per lock hold, O(n/32) mutex overhead |
| Selective request zeroing | `adaptive_ring.c:ring_get_request()` | Only zero variant fields, skip fields overwritten by caller |
| 1-in-8 latency sampling | `adaptive_ring.c:process_completion()` | ~1250 samples/sec at 10K IOPS, sufficient for P99 |
| TLS buffer cache | `adaptive_buffer.c` | Zero-lock fast path (~10ns), CAS-based registration |
| Cache-line layout | `adaptive_engine.h` | Hot atomics in cache line 0, cold tick state in line 1+ |
| Eventfd draining | `auraio.c:auraio_wait()` | Prevents spurious epoll wakeups after completions |
| Power-of-two ring spilling | `auraio.c:select_ring()` | ADAPTIVE mode: pick 2 random rings, use lighter one |
| Drift-free ticking | `auraio.c:tick_thread()` | `clock_nanosleep(TIMER_ABSTIME)` prevents drift from EINTR |
| TSan annotations | `internal.h` | `TSAN_RELEASE/ACQUIRE` for io_uring kernel synchronization |

## Thread Safety

| Component | Mechanism | Notes |
|-----------|-----------|-------|
| Ring submission | `pthread_mutex_t` per ring | Released during callback |
| Request state | Atomics (`pending`, `cancel_requested`) | Lock-free checks |
| Histogram recording | Atomic increments | No lock needed |
| Histogram swap | Atomic index flip | O(1) operation |
| Buffer TLS cache | Thread-local storage | Zero lock fast path |
| Buffer shards | Per-shard mutex | Round-robin selection |
| Engine stats | Atomics with release/acquire | ARM/PowerPC safe |
| C++ CallbackPool | Mutex-protected allocation | Short-lived |
| C++ pending_contexts_ | Mutex-protected map | Thread-safe cleanup |
| Rust Engine | `Send + Sync` | C library handles locking |
| Rust IoFuture | `Arc<Mutex<IoState>>` | Waker-based notification |
| Rust callback trampoline | `catch_unwind` | Prevents cross-FFI panic unwinding |
| Buffer/file registration | `pthread_rwlock_t` | Read lock during I/O, write lock during register/unregister |
| Ring selection counter | `_Atomic unsigned int` | Round-robin mode: atomic fetch-add |
| Average pending | `_Atomic int` | Updated by tick thread, read by ADAPTIVE select |

### Lock Hierarchy (prevents deadlock)
1. Buffer pool shards (independent, no nesting)
2. Ring locks (independent, no nesting)
3. Engine pending_mutex (C++ only, short-lived)

### Thread Roles
- **Application threads**: Submit I/O (per-ring locks)
- **Poll thread**: Single thread calls poll/wait (releases lock for callbacks)
- **Tick thread**: Runs every 10ms, lock-free stats via atomics
- **SQPOLL threads** (optional): Kernel threads auto-submit SQEs
- **Rust background poller** (async pattern): Calls `engine.wait()` for future progress

## Test Infrastructure

### Unit Tests

| Test | Focus | File |
|------|-------|------|
| test_engine | AIMD algorithm, phase transitions | `tests/test_engine.c` |
| test_ring | Ring lifecycle, submission, completion | `tests/test_ring.c` |
| test_buffer | Buffer pool alloc/free, size classes | `tests/test_buffer.c` |
| test_stats | Observability API, per-ring stats, histograms | `tests/test_stats.c` |
| test_ring_select | Ring selection modes, ADAPTIVE spill verification | `tests/test_ring_select.c` |
| test_cpp | C++ bindings, RAII, coroutines, concepts | `tests/test_cpp.cpp` |
| stress_test | Multi-threaded concurrent I/O | `tests/stress_test.cpp` |
| Rust tests | FFI bindings, safe API, async I/O | `bindings/rust/auraio/src/lib.rs` |

### Performance Benchmarks (`tests/perf_bench.c`)

Six benchmark modes:
- **Throughput**: 64K random reads, max inflight 256
- **Latency**: 4K serial reads, depth=1, min/avg/max/P99
- **Scalability**: Varying queue depth 4-128
- **Mixed**: 70% reads, 25% writes, 5% fsync
- **Syscall**: Measures ops per `io_uring_enter`
- **Buffer pool**: Multi-threaded alloc/free stress

Each benchmark runs in a separate fork to avoid io_uring kernel state contamination.

### Analysis Scripts

| Script | Purpose |
|--------|---------|
| `run_analysis.sh` | FIO comparison suite with apples-to-apples mode (recommended) |
| `run_deep_analysis.sh` | Flamegraphs, cachegrind, pahole, callgrind, perf c2c |
| `run_perf_test.sh` | Portable benchmark runner (earlier iteration) |

**`run_analysis.sh`** profiles: `--quick` (3s), `--standard` (5s), `--full` (10s). Generates Python report with FIO vs AuraIO comparison tables, percentage deltas, and key findings.

**`run_deep_analysis.sh`** phases: CPU flamegraphs, lock contention, cache behavior, struct layout (pahole), callgraph, false sharing detection. Generates automated optimization recommendations.

### Build Targets

```bash
# Core tests
make test              # C unit tests
make test-all          # C + C++ + Rust with unified summary

# Sanitizers
make test-sanitizers   # Valgrind + TSan + ASan combined summary

# BFFIO benchmark tool
make BFFIO             # Build BFFIO
make BFFIO-test        # Run BFFIO functional tests (20+ tests)
make BFFIO-baseline    # FIO vs BFFIO comparison with delta report

# Benchmarks
make bench             # FIO comparison (5s/test)
make bench-quick       # Quick (3s/test)
make bench-deep        # Deep profiling (flamegraphs, cachegrind)

# Dependencies
make deps              # Interactive installer (kernel >= 6.0 required)
make deps-check        # Verify availability
```

## Conventions

- **Naming**: Snake_case; `auraio_` prefix for public, `ring_`/`adaptive_`/`buffer_` for internal
- **Types**: Opaque handles for public API, full structs internal
- **Memory**: Pre-allocate pools, avoid malloc on hot paths
- **Locking**: Release around callbacks, batch to reduce lock acquisitions
- **Errors**: Return negative errno (C), throw `auraio::Error` (C++), `Result<T>` (Rust)
- **C++ Style**: RAII, move-only semantics, concepts for type safety
- **Rust Style**: RAII via Drop, `NonNull` for pointer safety, extension traits for async
- **C11 Compliance**: `_Thread_local` (not `__thread`), `_Static_assert`, `<stdatomic.h>` with explicit memory orderings
- **Build**: `-Wall -Wextra -Wshadow -Wpedantic -std=c11 -O2 -fPIC -fvisibility=hidden`

## Gotchas

1. **Request handle lifetime**: Only valid until callback begins - do not store
2. **Callback deadlock**: Never call `auraio_destroy()` from callback
3. **Shutdown order**: Stop worker threads before calling `auraio_destroy()`
4. **Buffer pool TLS**: Only first pool accessed per thread gets cache benefit
5. **Registered buffer lifetime**: No in-flight I/O during unregister
6. **SQPOLL**: May silently fall back without root/CAP_SYS_NICE
7. **Low-IOPS devices**: Tick may skip if < 20 samples and < 100ms elapsed
8. **Histogram race (FIXED)**: Uses `adaptive_hist_reset()` with atomic stores, not memset
9. **process_completion() locking**: Callers must NOT hold lock when calling it
10. **Rust inline functions**: `auraio_buf`/`auraio_buf_fixed` reimplemented (bindgen can't handle inline)
11. **Rust async polling**: Futures don't progress without background `engine.wait()` calls
12. **Rust RequestHandle**: Becomes dangling pointer after callback starts (most dangerous Rust gotcha)
13. **Prometheus histogram sum**: Estimated via midpoint (not exact)
14. **Coroutine ownership**: Task must remain alive until completion; destructor asserts if still pending
15. **Coroutine result**: `Task<T>::get()` is destructive — moves result out, subsequent calls throw `std::logic_error`
16. **Registered file update**: `auraio_update_file()` is non-atomic across rings — partial failure leaves inconsistent state
17. **C++ BufferRef const**: Explicit constructor from `const void*` prevents accidental use with read operations
18. **TSan ASLR**: Kernel >= 6.5 needs `setarch --addr-no-randomize` workaround

## Navigation Guide

**To add a new public API function**:
1. Declare in `include/auraio.h`
2. Implement in `src/auraio.c`
3. Add C++ wrapper in `include/auraio/engine.hpp`
4. Add Rust wrapper in `bindings/rust/auraio/src/engine.rs`
5. Re-export from `bindings/rust/auraio/src/lib.rs`

**To modify adaptive tuning behavior**:
1. Constants at top of `src/adaptive_engine.h`
2. Algorithm in `adaptive_tick()` in `src/adaptive_engine.c`

**To add a new I/O operation type**:
1. Add enum value to `auraio_op_type_t` in `src/adaptive_ring.h`
2. Add `ring_submit_*()` function in `src/adaptive_ring.c`
3. Expose via public API in `auraio.c` and `auraio.h`
4. Add C++ method in `include/auraio/engine.hpp`
5. Add awaitable in `include/auraio/coro.hpp` if applicable
6. Add Rust method in `bindings/rust/auraio/src/engine.rs`
7. Add async variant in `bindings/rust/auraio/src/async_io.rs` if applicable

**To add a new BFFIO feature**:
1. Add config field to `job_config_t` in `tools/BFFIO/job_parser.h`
2. Parse it in `job_parser.c` (both CLI and .fio file paths)
3. Use it in `workload.c` I/O loop
4. Output it in `output.c` (both normal text and JSON)
5. Add test case in `test_BFFIO.sh`

**To add Prometheus metrics**:
1. Add stat to public API in `include/auraio.h` (if new)
2. Add formatting in `exporters/prometheus/auraio_prometheus.c`

**To add a new Rust feature**:
1. Implement in appropriate `bindings/rust/auraio/src/*.rs` file
2. Re-export from `lib.rs`
3. Add tests in `lib.rs` test module
4. Add example in `examples/rust/examples/`

**Build and test**:
```bash
orb -m Caliente-dev bash -c "make test"           # C tests
orb -m Caliente-dev bash -c "make test-all"       # C + C++ + Rust
orb -m Caliente-dev bash -c "make test-sanitizers" # Valgrind + TSan + ASan
orb -m Caliente-dev bash -c "make bench"           # Performance vs FIO
```

## Examples Reference

| Example | Language | Purpose |
|---------|----------|---------|
| `quickstart.c/cpp/rs` | C/C++/Rust | Minimal async read |
| `simple_read.c/cpp/rs` | C/C++/Rust | Read with stats |
| `bulk_reader.c/cpp/rs` | C/C++/Rust | High-throughput scanner |
| `write_modes.c/cpp/rs` | C/C++/Rust | O_DIRECT vs buffered |
| `cancel_request.c` | C | In-flight request cancellation |
| `coroutine_copy.cpp` | C++20 | Coroutine file copy |
| `file_copy.rs` | Rust | Synchronous-style copy |
| `async_copy.rs` | Rust | Future-based async copy |

## Documentation Reference

| Document | Covers |
|----------|--------|
| `docs/api_reference.md` | Complete C/C++ API: types, functions, error codes, callback rules |
| `docs/architecture.md` | Design philosophy, concurrency model, migration guide |
| `docs/observability.md` | Metrics API, Prometheus integration, sampling cost analysis, PromQL examples |
| `docs/performance.md` | Hardware-aware I/O design, buffer registration, optimization tips, internal micro-optimizations |
| `docs/BFFIO.md` | BFFIO benchmark tool: usage, --target-p99, output formats, architecture |
