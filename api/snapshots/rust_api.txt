# file: bindings/rust/auraio/src/async_io.rs
pub struct IoFuture {
pub trait AsyncEngine {

# file: bindings/rust/auraio/src/buffer.rs
pub struct Buffer {
pub fn as_slice(&self) -> &[u8] {
pub fn as_mut_slice(&mut self) -> &mut [u8] {
pub fn as_ptr(&self) -> *const u8 {
pub fn as_mut_ptr(&mut self) -> *mut u8 {
pub fn len(&self) -> usize {
pub fn is_empty(&self) -> bool {
pub fn to_ref(&self) -> BufferRef {
pub struct BufferRef {
pub unsafe fn from_ptr(ptr: *mut std::ffi::c_void) -> Self {
pub unsafe fn from_slice(slice: &[u8]) -> Self {
pub unsafe fn from_mut_slice(slice: &mut [u8]) -> Self {
pub fn fixed(index: i32, offset: usize) -> Self {
pub fn fixed_index(index: i32) -> Self {

# file: bindings/rust/auraio/src/callback.rs
pub fn new<F>(callback: F) -> Box<Self>

# file: bindings/rust/auraio/src/engine.rs
pub struct Engine {
pub fn new() -> Result<Self> {
pub fn with_options(options: &Options) -> Result<Self> {
pub fn as_ptr(&self) -> *mut auraio_sys::auraio_engine_t {
pub fn allocate_buffer(&self, size: usize) -> Result<Buffer> {
pub unsafe fn register_buffers(&self, buffers: &[&mut [u8]]) -> Result<()> {
pub fn unregister_buffers(&self) -> Result<()> {
pub fn register_files(&self, fds: &[RawFd]) -> Result<()> {
pub fn update_file(&self, index: i32, fd: RawFd) -> Result<()> {
pub fn unregister_files(&self) -> Result<()> {
pub unsafe fn read<F>(
pub unsafe fn write<F>(
pub fn fsync<F>(&self, fd: RawFd, callback: F) -> Result<RequestHandle>
pub fn fdatasync<F>(&self, fd: RawFd, callback: F) -> Result<RequestHandle>
pub unsafe fn readv<F>(
pub unsafe fn writev<F>(
pub unsafe fn cancel(&self, request: &RequestHandle) -> Result<()> {
pub fn poll_fd(&self) -> Result<RawFd> {
pub fn poll(&self) -> Result<usize> {
pub fn wait(&self, timeout_ms: i32) -> Result<usize> {
pub fn run(&self) {
pub fn stop(&self) {
pub fn stats(&self) -> Stats {
pub fn version() -> &'static str {
pub fn version_int() -> i32 {

# file: bindings/rust/auraio/src/error.rs
pub enum Error {
pub type Result<T> = std::result::Result<T, Error>;
pub fn from_raw_os_error(code: i32) -> Self {

# file: bindings/rust/auraio/src/lib.rs
pub mod async_io;
pub use buffer::{Buffer, BufferRef};
pub use engine::{version, version_int, Engine};
pub use error::{Error, Result};
pub use options::Options;
pub use request::RequestHandle;
pub use stats::Stats;
pub use async_io::{AsyncEngine, IoFuture};
pub use libc::iovec;

# file: bindings/rust/auraio/src/options.rs
pub enum RingSelect {
pub struct Options {
pub fn new() -> Self {
pub fn queue_depth(mut self, depth: i32) -> Self {
pub fn ring_count(mut self, count: i32) -> Self {
pub fn initial_in_flight(mut self, limit: i32) -> Self {
pub fn min_in_flight(mut self, limit: i32) -> Self {
pub fn max_p99_latency_ms(mut self, latency: f64) -> Self {
pub fn buffer_alignment(mut self, alignment: usize) -> Self {
pub fn disable_adaptive(mut self, disable: bool) -> Self {
pub fn enable_sqpoll(mut self, enable: bool) -> Self {
pub fn sqpoll_idle_ms(mut self, timeout: i32) -> Self {
pub fn ring_select(mut self, mode: RingSelect) -> Self {

# file: bindings/rust/auraio/src/request.rs
pub struct RequestHandle {
pub unsafe fn is_pending(&self) -> bool {
pub unsafe fn fd(&self) -> RawFd {

# file: bindings/rust/auraio/src/stats.rs
pub struct Stats {
pub fn ops_completed(&self) -> i64 {
pub fn bytes_transferred(&self) -> i64 {
pub fn throughput_bps(&self) -> f64 {
pub fn p99_latency_ms(&self) -> f64 {
pub fn current_in_flight(&self) -> i32 {
pub fn optimal_in_flight(&self) -> i32 {
pub fn optimal_batch_size(&self) -> i32 {
pub fn adaptive_spills(&self) -> u64 {


