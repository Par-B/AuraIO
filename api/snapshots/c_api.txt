#ifndef AURAIO_H
#define AURAIO_H
#include <stdbool.h>
#include <string.h>
#define AURAIO_VERSION_MAJOR 0
#define AURAIO_VERSION_MINOR 1
#define AURAIO_VERSION_PATCH 0
#define AURAIO_VERSION \
(AURAIO_VERSION_MAJOR * 10000 + AURAIO_VERSION_MINOR * 100 + AURAIO_VERSION_PATCH)
#define AURAIO_VERSION_STRING "0.1.0"
#if AURAIO_VERSION_MINOR > 99 || AURAIO_VERSION_PATCH > 99
# error "Version minor/patch must be 0-99 for packed AURAIO_VERSION integer"
#endif
#if defined(AURAIO_SHARED_BUILD)
# define AURAIO_API __attribute__((visibility("default")))
#elif defined(AURAIO_STATIC_BUILD)
# define AURAIO_API
#else
# define AURAIO_API
#endif
#if defined(__GNUC__) || defined(__clang__)
# define AURAIO_WARN_UNUSED __attribute__((warn_unused_result))
#else
# define AURAIO_WARN_UNUSED
#endif
#include <stddef.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/uio.h>
#ifdef __cplusplus
extern "C" {
#endif
typedef struct auraio_engine auraio_engine_t;
typedef struct auraio_request auraio_request_t;
typedef void (*auraio_callback_t)(auraio_request_t *req, ssize_t result, void *user_data);
typedef struct {
int64_t ops_completed;
int64_t bytes_transferred;
double current_throughput_bps;
double p99_latency_ms;
int current_in_flight;
int optimal_in_flight;
int optimal_batch_size;
uint64_t adaptive_spills;
uint32_t _reserved[4];
} auraio_stats_t;
typedef struct {
int64_t ops_completed;
int64_t bytes_transferred;
int pending_count;
int in_flight_limit;
int batch_threshold;
double p99_latency_ms;
double throughput_bps;
int aimd_phase;
int queue_depth;
uint32_t _reserved[4];
} auraio_ring_stats_t;
#define AURAIO_PHASE_BASELINE 0
#define AURAIO_PHASE_PROBING 1
#define AURAIO_PHASE_STEADY 2
#define AURAIO_PHASE_BACKOFF 3
#define AURAIO_PHASE_SETTLING 4
#define AURAIO_PHASE_CONVERGED 5
#define AURAIO_HISTOGRAM_BUCKETS 200
#define AURAIO_HISTOGRAM_BUCKET_WIDTH_US 50
typedef struct {
uint32_t buckets[AURAIO_HISTOGRAM_BUCKETS];
uint32_t overflow;
uint32_t total_count;
int bucket_width_us;
int max_tracked_us;
uint32_t _reserved[2];
} auraio_histogram_t;
typedef struct {
size_t total_allocated_bytes;
size_t total_buffers;
int shard_count;
uint32_t _reserved[4];
} auraio_buffer_stats_t;
typedef enum {
AURAIO_SELECT_ADAPTIVE = 0,
AURAIO_SELECT_CPU_LOCAL,
AURAIO_SELECT_ROUND_ROBIN
} auraio_ring_select_t;
typedef struct {
size_t struct_size;
int queue_depth;
int ring_count;
int initial_in_flight;
int min_in_flight;
double max_p99_latency_ms;
size_t buffer_alignment;
bool disable_adaptive;
bool enable_sqpoll;
int sqpoll_idle_ms;
auraio_ring_select_t ring_select;
} auraio_options_t;
typedef enum {
AURAIO_FSYNC_DEFAULT = 0,
AURAIO_FSYNC_DATASYNC = 1,
} auraio_fsync_flags_t;
typedef enum {
AURAIO_BUF_UNREGISTERED = 0,
AURAIO_BUF_REGISTERED = 1
} auraio_buf_type_t;
typedef struct {
auraio_buf_type_t type;
union {
void *ptr;
struct {
int index;
size_t offset;
} fixed;
} u;
} auraio_buf_t;
static inline auraio_buf_t auraio_buf(void *ptr) {
auraio_buf_t buf;
memset(&buf, 0, sizeof(buf));
buf.type = AURAIO_BUF_UNREGISTERED;
buf.u.ptr = ptr;
return buf;
}
static inline auraio_buf_t auraio_buf_fixed(int index, size_t offset) {
auraio_buf_t buf;
memset(&buf, 0, sizeof(buf));
if (index < 0) {
return buf;
}
buf.type = AURAIO_BUF_REGISTERED;
buf.u.fixed.index = index;
buf.u.fixed.offset = offset;
return buf;
}
static inline auraio_buf_t auraio_buf_fixed_idx(int index) {
return auraio_buf_fixed(index, 0);
}
AURAIO_API void auraio_options_init(auraio_options_t *options);
AURAIO_API AURAIO_WARN_UNUSED auraio_engine_t *auraio_create(void);
AURAIO_API AURAIO_WARN_UNUSED auraio_engine_t *
auraio_create_with_options(const auraio_options_t *options);
AURAIO_API void auraio_destroy(auraio_engine_t *engine);
AURAIO_API AURAIO_WARN_UNUSED auraio_request_t *
auraio_read(auraio_engine_t *engine, int fd, auraio_buf_t buf, size_t len, off_t offset,
auraio_callback_t callback, void *user_data);
AURAIO_API AURAIO_WARN_UNUSED auraio_request_t *
auraio_write(auraio_engine_t *engine, int fd, auraio_buf_t buf, size_t len, off_t offset,
auraio_callback_t callback, void *user_data);
AURAIO_API AURAIO_WARN_UNUSED auraio_request_t *
auraio_fsync(auraio_engine_t *engine, int fd, auraio_callback_t callback, void *user_data);
AURAIO_API AURAIO_WARN_UNUSED auraio_request_t *auraio_fsync_ex(auraio_engine_t *engine, int fd,
auraio_fsync_flags_t flags,
auraio_callback_t callback,
void *user_data);
AURAIO_API AURAIO_WARN_UNUSED auraio_request_t *
auraio_readv(auraio_engine_t *engine, int fd, const struct iovec *iov, int iovcnt, off_t offset,
auraio_callback_t callback, void *user_data);
AURAIO_API AURAIO_WARN_UNUSED auraio_request_t *
auraio_writev(auraio_engine_t *engine, int fd, const struct iovec *iov, int iovcnt, off_t offset,
auraio_callback_t callback, void *user_data);
AURAIO_API AURAIO_WARN_UNUSED int auraio_cancel(auraio_engine_t *engine, auraio_request_t *req);
AURAIO_API bool auraio_request_pending(const auraio_request_t *req);
AURAIO_API int auraio_request_fd(const auraio_request_t *req);
AURAIO_API void *auraio_request_user_data(const auraio_request_t *req);
AURAIO_API int auraio_get_poll_fd(const auraio_engine_t *engine);
AURAIO_API int auraio_poll(auraio_engine_t *engine);
AURAIO_API int auraio_wait(auraio_engine_t *engine, int timeout_ms);
AURAIO_API void auraio_run(auraio_engine_t *engine);
AURAIO_API void auraio_stop(auraio_engine_t *engine);
AURAIO_API int auraio_drain(auraio_engine_t *engine, int timeout_ms);
AURAIO_API AURAIO_WARN_UNUSED void *auraio_buffer_alloc(auraio_engine_t *engine, size_t size);
AURAIO_API void auraio_buffer_free(auraio_engine_t *engine, void *buf, size_t size);
AURAIO_API AURAIO_WARN_UNUSED int auraio_register_buffers(auraio_engine_t *engine,
const struct iovec *iovs, int count);
AURAIO_API int auraio_unregister_buffers(auraio_engine_t *engine);
AURAIO_API AURAIO_WARN_UNUSED int auraio_register_files(auraio_engine_t *engine, const int *fds,
int count);
AURAIO_API AURAIO_WARN_UNUSED int auraio_update_file(auraio_engine_t *engine, int index, int fd);
AURAIO_API int auraio_unregister_files(auraio_engine_t *engine);
AURAIO_API void auraio_get_stats(const auraio_engine_t *engine, auraio_stats_t *stats);
AURAIO_API int auraio_get_ring_count(const auraio_engine_t *engine);
AURAIO_API int auraio_get_ring_stats(const auraio_engine_t *engine, int ring_idx,
auraio_ring_stats_t *stats);
AURAIO_API int auraio_get_histogram(const auraio_engine_t *engine, int ring_idx,
auraio_histogram_t *hist);
AURAIO_API int auraio_get_buffer_stats(const auraio_engine_t *engine, auraio_buffer_stats_t *stats);
AURAIO_API const char *auraio_phase_name(int phase);
AURAIO_API const char *auraio_version(void);
AURAIO_API int auraio_version_int(void);
#ifdef __cplusplus
}
#endif
#endif

